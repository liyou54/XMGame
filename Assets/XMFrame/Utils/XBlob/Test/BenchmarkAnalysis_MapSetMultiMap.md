# XBlob 容器 vs Native 容器 性能基准分析

> 基于 `Benchmark_CompareAllContainersWithNative`：容器容量 10 万元素，读写/查询 100 万次。

---

## 一、测试条件简述

| 项 | 值 |
|----|-----|
| 容器容量 | 10 万元素 |
| 插入量 | 10 万次 |
| 查询/更新/存在检查量 | 100 万次 |
| 比率含义 | `XBlob耗时 / Native耗时`，<1 表示 XBlob 更快 |

---

## 二、分项结论

### 1. Map vs NativeHashMap

| 操作 | XBlob | Native | 比率 | 结论 |
|------|-------|--------|------|------|
| 插入(10万) | 7ms | 6ms | 1.17x | 略慢，可接受 |
| 查询(100万) | 25ms | 42ms | **0.60x** | 明显更快 |
| 更新(100万) | 54ms | 44ms | 1.23x | 略慢 |
| 存在检查(100万) | 26ms | 40ms | **0.65x** | 明显更快 |
| 迭代(10万) | 0ms | 4ms | **≈0** | 明显更快 |
| **合计** | 112ms | 136ms | **0.82x** | 整体更快 |

- **优势**：查询、HasKey、迭代都显著优于 NativeHashMap，适合「查多写少」或「大量存在检查 + 遍历」。
- **劣势**：插入、更新略慢（约 17%～23%），可能来自：  
  1）每次调用都传 `container` 的间接访问；  
  2）XBlob 哈希表在 Blob 内的布局/写回策略与 Native 不同。

---

### 2. Set vs NativeHashSet

| 操作 | XBlob | Native | 比率 | 结论 |
|------|-------|--------|------|------|
| 插入(10万) | 6ms | 5ms | 1.20x | 略慢 |
| 查询/Contains(100万) | 25ms | 38ms | **0.66x** | 明显更快 |
| 迭代(10万) | 1ms | 4ms | **0.25x** | 明显更快 |
| **合计** | 32ms | 47ms | **0.68x** | 整体更快 |

- **优势**：查询和迭代都远好于 NativeHashSet，适合「频繁 Contains + 全量遍历」。
- **劣势**：仅插入略慢约 20%，对总耗时影响很小。

---

### 3. MultiMap vs NativeParallelMultiHashMap

| 操作 | XBlob | Native | 比率 | 结论 |
|------|-------|--------|------|------|
| 插入(10万) | 7ms | 4ms | **1.75x** | 明显更慢 ✗ |
| 查询/ContainsKey(100万) | 24ms | 50ms | **0.48x** | 明显更快 |
| 迭代(10万) | 1ms | 6ms | **0.17x** | 明显更快 |
| **合计** | 32ms | 60ms | **0.53x** | 整体仍更快 |

- **优势**：查询和迭代远优于 Native，总耗时仍少约一半。
- **劣势**：插入慢约 75%（7ms vs 4ms），是三类容器里唯一「单项明显落后」的场景。  
  若业务以「一次性大批量插入 + 很少再查/遍历」为主，Native 会更合适；若插入后还有大量 ContainsKey 或遍历，XBlobMultiMap 更合适。

---

## 三、综合对比与适用场景

- **总耗时**：XBlob = 176ms，Native = 243ms，比率 **0.72x**，即 XBlob 总体约快 28%。
- **强项**：  
  - 所有「查询 / 存在检查 / 迭代」均优于对应 Native 容器。  
  - 迭代优势最大（Map/Set/MultiMap 的迭代都远快于 Native）。
- **弱项**：  
  - 插入普遍略慢（约 17%～25%），MultiMap 插入慢约 75%。  
  - Map 的「更新」略慢约 23%。

**适用场景归纳：**

| 场景 | 更推荐 |
|------|--------|
| 以查询、HasKey/Contains、遍历为主 | **XBlob**（Map/Set/MultiMap 都适合） |
| 以一次性大批量插入为主、几乎不再查 | Native（尤其是 MultiMap 插入） |
| 读写混合、需要统一放在同一 Blob 内管理 | **XBlob**（总耗时仍更好，且利于内存布局与生命周期统一） |
| 纯 Job 内、无 Blob 需求 | 视单次测试的插入/查询比例决定 |

---

## 四、可能原因（便于后续优化）

1. **查询/迭代更快**  
   - XBlob 哈希表在 Blob 内连续排布，缓存局部性可能更好。  
   - 迭代时按自己的布局顺序遍历，可能比 Native 的迭代路径更短、分支更少。

2. **插入/更新略慢**  
   - 每次调用需传 `container`，多一层间接访问。  
   - AddOrUpdate/Add 可能包含额外逻辑（如扩容/链表挂接等），与 Native 的实现路径不同。  
   - MultiMap 插入 1.75x 可能来自「多值链表」或「块分配」的开销，值得在实现上单独看一下热路径。

3. **迭代 0ms vs 4ms**  
   - 10 万量级、1ms 以下会算成 0ms，说明 XBlob 迭代在本机上的确非常快，与「紧凑布局 + 少分支」的假设一致。

---

## 五、一句话总结

在「10 万容量 + 100 万次查询/更新」的基准下，XBlob 的 Map/Set/MultiMap 在**总耗时**上均优于对应 Native 容器（约 0.5x～0.8x），主要赢在**查询、存在检查和迭代**；插入略慢，MultiMap 插入明显慢一档。若使用场景以「查多写少」或「写一次、查/遍历很多」为主，当前数据支持优先选用 XBlob 容器。
