# IPoolManager 使用指南

## 快速开始

### 基础使用

```csharp
// 1. 获取对象池
var pool = IPoolManager.I.GetOrCreatePool<MyClass>();

// 2. 从池中获取对象
var obj = pool.Get();

// 3. 使用对象
obj.DoSomething();

// 4. 释放回池
pool.Release(obj);
```

## 常见场景

### 场景 1: 游戏数据缓存

```csharp
public class PlayerData
{
    public int Id;
    public string Name;
    public Vector3 Position;
    
    public void Reset()
    {
        Id = 0;
        Name = string.Empty;
        Position = Vector3.zero;
    }
}

// 使用默认对象池
var pool = IPoolManager.I.GetOrCreatePool<PlayerData>();
var player = pool.Get();
player.Id = 1001;
player.Name = "玩家1";

// 使用完毕释放
pool.Release(player);
```

### 场景 2: 临时集合容器

```csharp
// 配置对象池
var config = new PoolConfig<List<int>>
{
    OnCreate = () => new List<int>(),
    OnRelease = (list) => list.Clear(),  // 释放时清空
    InitialCapacity = 5,
    MaxCapacity = 20
};

var pool = IPoolManager.I.GetOrCreatePool("IntListPool", config);

// 使用
var tempList = pool.Get();
tempList.Add(1);
tempList.Add(2);
tempList.Add(3);

// 处理数据...

// 释放（自动清空）
pool.Release(tempList);
```

### 场景 3: 技能效果数据

```csharp
public class SkillEffectData
{
    public int SkillId;
    public float Damage;
    public List<int> Targets;
    
    public void Reset()
    {
        SkillId = 0;
        Damage = 0;
        Targets?.Clear();
    }
}

var config = new PoolConfig<SkillEffectData>
{
    OnCreate = () => new SkillEffectData { Targets = new List<int>() },
    OnRelease = (data) => data.Reset(),
    InitialCapacity = 10,
    MaxCapacity = 50
};

var pool = IPoolManager.I.GetOrCreatePool("SkillEffectPool", config);

// 使用示例
void CastSkill(int skillId, List<int> targetIds)
{
    var effect = pool.Get();
    effect.SkillId = skillId;
    effect.Damage = 100;
    effect.Targets.AddRange(targetIds);
    
    // 处理技能逻辑...
    
    pool.Release(effect);
}
```

### 场景 4: 消息队列

```csharp
public class NetworkMessage
{
    public int MessageType;
    public byte[] Data;
    
    public void Reset()
    {
        MessageType = 0;
        Data = null;
    }
}

var config = new PoolConfig<NetworkMessage>
{
    OnCreate = () => new NetworkMessage(),
    OnGet = (msg) => Debug.Log($"消息被获取"),
    OnRelease = (msg) => 
    {
        msg.Reset();
        Debug.Log($"消息被释放");
    },
    InitialCapacity = 20,
    MaxCapacity = 100
};

var messagePool = IPoolManager.I.GetOrCreatePool("MessagePool", config);

// 发送消息时从池中获取
var msg = messagePool.Get();
msg.MessageType = 1001;
msg.Data = new byte[] { 1, 2, 3 };

// 发送完毕后释放
messagePool.Release(msg);
```

## 配置说明

### PoolConfig 参数

| 参数 | 类型 | 说明 | 默认值 |
|------|------|------|--------|
| OnCreate | Func\<T\> | 创建新对象的回调（必需） | null |
| OnDestroy | Action\<T\> | 销毁对象时的回调 | null |
| OnGet | Action\<T\> | 获取对象时的回调 | null |
| OnRelease | Action\<T\> | 释放对象时的回调 | null |
| InitialCapacity | int | 预创建的对象数量 | 0 |
| MaxCapacity | int | 最大保留对象数（0=无限制） | 0 |

### 回调时机

```
创建流程:
  OnCreate() → [对象被创建]

获取流程:
  [从池中获取或创建新对象] → OnGet(obj) → 返回给调用者

释放流程:
  OnRelease(obj) → [检查容量] → 放回池中 或 OnDestroy(obj)

销毁流程:
  OnDestroy(obj) → [对象被销毁]
```

## 常用方法

### IPoolManager 接口方法

```csharp
// 获取或创建默认对象池（使用 new() 创建对象）
IPool<T> GetOrCreatePool<T>() where T : new()

// 获取或创建自定义对象池
IPool<T> GetOrCreatePool<T>(string poolName, PoolConfig<T> config)

// 获取现有对象池（不存在返回 null）
IPool<T> GetPool<T>(string poolName)

// 检查对象池是否存在
bool HasPool<T>(string poolName)

// 销毁指定对象池
void DestroyPool<T>(string poolName)

// 销毁所有对象池
void DestroyAllPools()
```

### IPool\<T\> 接口方法

```csharp
// 从池中获取对象
T Get()

// 释放对象回池
void Release(T item)

// 清空池中所有对象
void Clear()

// 获取池中可用对象数量
int Count { get; }

// 获取当前激活的对象数量
int ActiveCount { get; }
```

## 注意事项

### ✅ 适合使用对象池的场景

- 频繁创建销毁的临时对象
- 数据结构（List、Dictionary、StringBuilder 等）
- 消息、事件、命令对象
- 游戏逻辑数据（技能数据、战斗结算等）
- 网络消息包

### ❌ 不适合使用对象池的场景

- UnityEngine.Object（GameObject、Component 等）
  - 请使用 Unity 的对象池或资源管理系统
- 需要明确生命周期的持久化对象
- 单例对象
- 非常大的对象（序列化数据、大型缓存等）

### 常见错误

```csharp
// ❌ 错误 1: 忘记释放对象
var obj = pool.Get();
// 使用后没有调用 pool.Release(obj)

// ❌ 错误 2: 重复释放
pool.Release(obj);
pool.Release(obj);  // 会触发警告

// ❌ 错误 3: 释放后继续使用
pool.Release(obj);
obj.DoSomething();  // 危险！对象可能已被其他地方获取

// ❌ 错误 4: 对 Unity 对象使用
var pool = IPoolManager.I.GetOrCreatePool<GameObject>();  // 不支持！
```

## 性能建议

### 1. 合理设置初始容量

```csharp
// 根据实际使用量设置，避免运行时频繁分配
InitialCapacity = 10  // 游戏中同时存在约 10 个
```

### 2. 设置最大容量防止内存泄漏

```csharp
MaxCapacity = 100  // 超过 100 个后销毁而不是保留
```

### 3. 在 OnRelease 中重置对象

```csharp
OnRelease = (obj) =>
{
    obj.Reset();      // 清理所有状态
    obj.RefCount = 0; // 重置计数器
}
```

### 4. 预热对象池

```csharp
// 在游戏启动或场景加载时预热
var config = new PoolConfig<BulletData>
{
    OnCreate = () => new BulletData(),
    InitialCapacity = 50  // 预创建 50 个
};
```

## 调试技巧

### 监控对象池状态

```csharp
var pool = IPoolManager.I.GetOrCreatePool<MyClass>();
Debug.Log($"池名称: MyClass");
Debug.Log($"空闲对象: {pool.Count}");
Debug.Log($"激活对象: {pool.ActiveCount}");
```

### 添加日志追踪

```csharp
var config = new PoolConfig<MyClass>
{
    OnCreate = () =>
    {
        Debug.Log("[Pool] 创建新对象");
        return new MyClass();
    },
    OnGet = (obj) => Debug.Log($"[Pool] 获取对象"),
    OnRelease = (obj) => Debug.Log($"[Pool] 释放对象"),
    OnDestroy = (obj) => Debug.Log($"[Pool] 销毁对象")
};
```

## 完整示例

查看 `PoolManagerExample.cs` 获取更多详细示例。

## 技术支持

遇到问题请查看：
- `README.md` - 详细技术文档
- `PoolManagerExample.cs` - 完整示例代码
- `IPoolManager.cs` - 接口定义
- `PoolManager.cs` - 具体实现
