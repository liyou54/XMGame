using System;
using System.Linq;
using XM.ConfigNew.Metadata;

namespace XM.ConfigNew.CodeGen.Builders
{
    /// <summary>
    /// 索引初始化代码生成器
    /// 负责生成配置管理器中索引的初始化和填充逻辑
    /// </summary>
    public class IndexInitializationBuilder
    {
        private readonly ConfigClassMetadata _classMetadata;
        private readonly CodeBuilder _builder;
        
        public IndexInitializationBuilder(ConfigClassMetadata classMetadata, CodeBuilder builder)
        {
            _classMetadata = classMetadata ?? throw new ArgumentNullException(nameof(classMetadata));
            _builder = builder ?? throw new ArgumentNullException(nameof(builder));
        }
        
        #region 辅助方法
        
        /// <summary>
        /// 生成索引Map变量名
        /// </summary>
        private static string GetIndexMapVarName(string indexName)
        {
            return CodeGenConstants.IndexMapVarPrefix + indexName + CodeGenConstants.IndexMapVarSuffix;
        }
        
        /// <summary>
        /// 生成索引键变量名
        /// </summary>
        private static string GetIndexKeyVarName(string indexName)
        {
            return CodeGenConstants.IndexKeyVarPrefix + indexName;
        }
        
        /// <summary>
        /// 生成索引容量变量名
        /// </summary>
        private static string GetIndexCapacityVarName(string indexName)
        {
            return CodeGenConstants.IndexCapacityVarPrefix + indexName;
        }
        
        /// <summary>
        /// 获取索引结构体全名
        /// </summary>
        private string GetIndexStructName(ConfigIndexMetadata index)
        {
            return $"{_classMetadata.UnmanagedTypeName}.{index.GeneratedStructName}";
        }
        
        #endregion
        
        /// <summary>
        /// 生成索引初始化方法（支持两遍扫描）
        /// </summary>
        public void GenerateIndexInitializationMethod()
        {
            if (!_classMetadata.HasIndexes)
                return;
            
            var unmanagedTypeName = TypeHelper.GetGlobalQualifiedTypeName(_classMetadata.UnmanagedType);
            var hasLinkIndexes = _classMetadata.Indexes.Any(idx => idx.IsAutoGeneratedForLink);
            
            _builder.AppendXmlComment("初始化索引并填充数据",
                new System.Collections.Generic.Dictionary<string, string>
                {
                    { "configData", "配置数据容器" },
                    { "tableMap", "表的主数据 Map (CfgI -> TUnmanaged)" }
                });
            
            _builder.AppendLine("public void InitializeIndexes(");
            _builder.PushIndent();
            _builder.AppendLine("ref XM.ConfigData configData,");
            _builder.AppendLine($"XBlobMap<CfgI, {unmanagedTypeName}> tableMap)");
            _builder.PopIndent();
            _builder.BeginBlock();
            
            _builder.AppendComment("获取配置数量");
            _builder.AppendLine("int configCount = tableMap.GetLength(configData.BlobContainer);");
            _builder.AppendLine();
            
            // 如果有 XMLLink 索引，需要两遍扫描
            if (hasLinkIndexes)
            {
                GenerateTwoPassIndexing(unmanagedTypeName);
            }
            else
            {
                GenerateSinglePassIndexing();
            }
            
            _builder.EndMethod();
        }
        
        /// <summary>
        /// 生成单遍索引初始化（无 XMLLink 索引时使用）
        /// </summary>
        private void GenerateSinglePassIndexing()
        {
            // 为每个索引生成初始化代码
            foreach (var index in _classMetadata.Indexes)
            {
                GenerateIndexInitialization(index);
                _builder.AppendLine();
            }
            
            // 遍历所有配置，填充索引
            _builder.AppendComment("遍历所有配置，填充索引");
            _builder.AppendLine("for (int i = 0; i < configCount; i++)");
            _builder.BeginBlock();
            _builder.AppendLine("var cfgId = tableMap.GetKey(configData.BlobContainer, i);");
            _builder.AppendLine($"ref var data = ref tableMap.GetRef(configData.BlobContainer, cfgId, out bool exists);");
            _builder.AppendLine("if (!exists) continue;");
            _builder.AppendLine();
            
            // 为每个索引生成填充代码
            foreach (var index in _classMetadata.Indexes)
            {
                GenerateIndexFillInLoop(index);
                _builder.AppendLine();
            }
            
            _builder.EndBlock(); // end for loop
        }
        
        /// <summary>
        /// 生成两遍索引初始化（有 XMLLink 索引时使用）
        /// 第一遍：统计 XMLLink 索引容量
        /// 第二遍：创建索引并填充数据
        /// </summary>
        private void GenerateTwoPassIndexing(string unmanagedTypeName)
        {
            var linkIndexes = _classMetadata.Indexes.Where(idx => idx.IsAutoGeneratedForLink).ToList();
            var normalIndexes = _classMetadata.Indexes.Where(idx => !idx.IsAutoGeneratedForLink).ToList();
            
            // 第一遍：统计 XMLLink 索引容量
            _builder.AppendComment("第一遍：统计 XMLLink 索引容量");
            
            foreach (var index in linkIndexes)
            {
                _builder.AppendLine($"int {GetIndexCapacityVarName(index.IndexName)} = 0;");
            }
            _builder.AppendLine();
            
            _builder.AppendLine("for (int i = 0; i < configCount; i++)");
            _builder.BeginBlock();
            _builder.AppendLine("var cfgId = tableMap.GetKey(configData.BlobContainer, i);");
            _builder.AppendLine($"ref var data = ref tableMap.GetRef(configData.BlobContainer, cfgId, out bool exists);");
            _builder.AppendLine("if (!exists) continue;");
            _builder.AppendLine();
            
            foreach (var index in linkIndexes)
            {
                var parentField = index.IndexFields[0];
                _builder.AppendComment($"统计索引 {index.IndexName} 的有效引用数");
                _builder.AppendLine($"if (data.{parentField.FieldName}.Valid)");
                _builder.AppendLine($"    {GetIndexCapacityVarName(index.IndexName)}++;");
                _builder.AppendLine();
            }
            
            _builder.EndBlock();
            _builder.AppendLine();
            
            // 第二遍：创建索引并填充数据
            _builder.AppendComment("第二遍：创建索引容器");
            
            // 为 XMLLink 索引创建容器（使用统计的容量）
            foreach (var index in linkIndexes)
            {
                var indexStructName = GetIndexStructName(index);
                var indexVarName = GetIndexMapVarName(index.IndexName);
                var capacityVar = GetIndexCapacityVarName(index.IndexName);
                var allocMethod = index.IsUnique ? "AllocIndex" : "AllocMultiIndex";
                
                _builder.AppendComment($"索引: {index.IndexName} (XMLLink 自动生成)");
                _builder.AppendLine($"var {indexVarName} = configData.{allocMethod}<{indexStructName}, {unmanagedTypeName}>({indexStructName}.IndexType, {capacityVar});");
            }
            _builder.AppendLine();
            
            // 为普通索引创建容器（使用 configCount）
            foreach (var index in normalIndexes)
            {
                GenerateIndexInitialization(index);
                _builder.AppendLine();
            }
            
            // 遍历所有配置，填充索引
            _builder.AppendComment("遍历所有配置，填充索引数据");
            _builder.AppendLine("for (int i = 0; i < configCount; i++)");
            _builder.BeginBlock();
            _builder.AppendLine("var cfgId = tableMap.GetKey(configData.BlobContainer, i);");
            _builder.AppendLine($"ref var data = ref tableMap.GetRef(configData.BlobContainer, cfgId, out bool exists);");
            _builder.AppendLine("if (!exists) continue;");
            _builder.AppendLine();
            
            // 填充所有索引
            foreach (var index in _classMetadata.Indexes)
            {
                if (index.IsAutoGeneratedForLink)
                {
                    GenerateLinkIndexFillInLoop(index);
                }
                else
                {
                    GenerateIndexFillInLoop(index);
                }
                _builder.AppendLine();
            }
            
            _builder.EndBlock(); // end for loop
        }
        
        /// <summary>
        /// 生成单个索引的初始化代码
        /// </summary>
        private void GenerateIndexInitialization(ConfigIndexMetadata index)
        {
            _builder.AppendComment($"初始化索引: {index.IndexName}");
            
            // 特殊情况：如果索引字段只有一个且类型为 CfgS，自动变成索引
            bool isAutoIndex = index.IsSingleFieldIndex && 
                               TypeHelper.IsCfgSType(index.IndexFields[0].TypeInfo.ManagedFieldType);
            
            if (isAutoIndex)
            {
                _builder.AppendComment($"索引字段 {index.IndexFields[0].FieldName} 为 CfgS 类型，自动作为索引");
            }
            
            // 根据是否为唯一索引选择容器类型
            if (index.IsUnique)
            {
                GenerateUniqueIndexInitialization(index);
            }
            else
            {
                GenerateMultiValueIndexInitialization(index);
            }
        }
        
        /// <summary>
        /// 生成唯一索引的初始化代码（使用 XBlobMap）
        /// </summary>
        private void GenerateUniqueIndexInitialization(ConfigIndexMetadata index)
        {
            var indexStructName = GetIndexStructName(index);
            var indexVarName = GetIndexMapVarName(index.IndexName);
            var unmanagedTypeName = TypeHelper.GetGlobalQualifiedTypeName(_classMetadata.UnmanagedType);
            
            _builder.AppendComment($"申请 Map 容器，容量为配置数量");
            _builder.AppendLine($"var {indexVarName} = configData.AllocIndex<{indexStructName}, {unmanagedTypeName}>({indexStructName}.IndexType, configCount);");
        }
        
        /// <summary>
        /// 生成多值索引的初始化代码（使用 XBlobMultiMap）
        /// </summary>
        private void GenerateMultiValueIndexInitialization(ConfigIndexMetadata index)
        {
            var indexStructName = GetIndexStructName(index);
            var indexVarName = GetIndexMapVarName(index.IndexName);
            var unmanagedTypeName = TypeHelper.GetGlobalQualifiedTypeName(_classMetadata.UnmanagedType);
            
            _builder.AppendComment($"申请 MultiMap 容器，容量为配置数量");
            _builder.AppendLine($"var {indexVarName} = configData.AllocMultiIndex<{indexStructName}, {unmanagedTypeName}>({indexStructName}.IndexType, configCount);");
        }
        
        /// <summary>
        /// 生成在循环中填充单个索引的代码
        /// </summary>
        private void GenerateIndexFillInLoop(ConfigIndexMetadata index)
        {
            var indexStructName = GetIndexStructName(index);
            var indexVarName = GetIndexMapVarName(index.IndexName);
            var indexKeyVarName = GetIndexKeyVarName(index.IndexName);
            
            _builder.AppendComment($"填充索引: {index.IndexName}");
            
            // 构建索引键
            var keyParams = string.Join(", ", index.IndexFields.Select(f => $"data.{f.FieldName}"));
            _builder.AppendLine($"var {indexKeyVarName} = new {indexStructName}({keyParams});");
            
            // 根据是否为唯一索引选择添加方式
            if (index.IsUnique)
            {
                _builder.AppendLine($"if (!{indexVarName}.{CodeGenConstants.AddOrUpdateMethod}(configData.BlobContainer, {indexKeyVarName}, cfgId))");
                _builder.BeginBlock();
                _builder.AppendLine($"UnityEngine.Debug.LogWarning($\"{CodeGenConstants.IndexDuplicateKeyWarning.Replace("{0}", index.IndexName).Replace("{1}", $"{{{indexKeyVarName}}}")}\");");
                _builder.EndBlock();
            }
            else
            {
                _builder.AppendLine($"{indexVarName}.{CodeGenConstants.SetAddMethod}(configData.BlobContainer, {indexKeyVarName}, cfgId);");
            }
        }
        
        /// <summary>
        /// 生成在循环中填充 XMLLink 索引的代码
        /// 包含父节点有效性检查和唯一性冲突警告
        /// </summary>
        private void GenerateLinkIndexFillInLoop(ConfigIndexMetadata index)
        {
            var indexStructName = GetIndexStructName(index);
            var indexVarName = GetIndexMapVarName(index.IndexName);
            var indexKeyVarName = GetIndexKeyVarName(index.IndexName);
            
            var parentField = index.IndexFields[0];
            
            _builder.AppendComment($"填充索引: {index.IndexName} (XMLLink)");
            
            // 检查父节点 CfgI 是否有效
            _builder.AppendLine($"if (data.{parentField.FieldName}.Valid)");
            _builder.BeginBlock();
            
            // 构建索引键
            var keyParams = string.Join(", ", index.IndexFields.Select(f => $"data.{f.FieldName}"));
            _builder.AppendLine($"var {indexKeyVarName} = new {indexStructName}({keyParams});");
            
            // 根据是否为唯一索引选择添加方式
            if (index.IsUnique)
            {
                _builder.AppendComment("唯一索引：冲突时覆盖并警告");
                _builder.AppendLine($"if (!{indexVarName}.{CodeGenConstants.AddOrUpdateMethod}(configData.BlobContainer, {indexKeyVarName}, cfgId))");
                _builder.BeginBlock();
                _builder.AppendLine($"UnityEngine.Debug.LogWarning($\"{CodeGenConstants.XmlLinkUniqueConflictWarning.Replace("{0}", $"{{{indexKeyVarName}}}").Replace("{1}", "{cfgId}")}\");");
                _builder.EndBlock();
            }
            else
            {
                _builder.AppendComment("多值索引：允许一个父节点有多个子Link");
                _builder.AppendLine($"{indexVarName}.{CodeGenConstants.SetAddMethod}(configData.BlobContainer, {indexKeyVarName}, cfgId);");
            }
            
            _builder.EndBlock(); // end if Valid
        }
        
        /// <summary>
        /// 生成索引字段声明（不再需要，索引容器在方法内部作为局部变量）
        /// </summary>
        public void GenerateIndexFields()
        {
            // 索引容器现在作为 InitializeIndexes 方法的局部变量，不需要私有字段
        }
    }
}
